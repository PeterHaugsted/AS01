Manual for the 'myshell.c' shell interpreter:

TABLE OF CONTENTS:
1. User manual
    1.1 How to run the shell
    1.2 Example of use
    1.3 Using pipes

2. Useful knowledge
    2.1 System calls
    2.2 I/O redirection
    2.3 Program environment
    2.4 Background program execution

---------- 0. FOREWORD ----------
This usermanual is intended for people with a basic understanding on how to operate in a LINUX terminal.

---------- 1. USER MANUAL ----------
The program 'myshell.c' is a Linux shell command interpreter which provides the interface between a user and a kernel, for the user to use various operating system services. The program accepts commands readable by humans, and converts these into 'kernel language'. This program is a 'Command Line Shell' in which the user interacts with a terminal in a Linux system.  

    ----- 1.1 HOW TO RUN THE SHELL -----
There are 3 steps to running this program. 

First, navigate to the directory in which 'myshell.c' is located, using the 'cd' command in your linux terminal, to double check if you're in the right directory, simply enter 'll'. This prints a list of directory contents to the terminal, where the file 'myshell.c' should be shown.

For the program to run you need to compile it using 'gcc'.
Enter 'gcc myshell.c' to compile the program. If the command 'gcc' is not found, gcc is not installed. This is easily corrected with the command 'sudo apt install gcc'.

When compiled, simply enter './a.out' to execute the program, the program is now running, anything you write in the shell hereon will be interperated by 'myshell.c'. 

    ----- 1.2 EXAMPLE OF USE -----
An example on how to use the program could be sorting a '.txt' document alphabetically. This is done by first placing the .txt file in the directory in which 'myshell.c' is executed from, and running the command 'cat (filename) | sort'

Your '.txt' file is now printed in alphabetical order to the terminal.

    ----- 1.3 USING PIPES -----
The ability to use pipes is implemented in myshell.c.
The example above illustrates the use of pipes. The symbol '|' 'pipes' the output of one command to the input of another. 
The syntax is as follows: 
'[command x] [arguments] | [command y] [arguments]'
Remember to seperate commands and arguments with spaces.
The output of command x becomes the input for command y. Thus, inputs for command y do not need to be specified. In theory, you can chain together an unlimited number of commands (until you run out of memory) with pipes.


---------- 2. USEFUL KNOWLEDGE ----------
A lot happens 'behind the scenes' when executing a program. This section covers some of the basic concepts.

    ----- 2.1 SYSTEM CALLS -----
    In this section the term 'process' is used. This is the actual task running on the processor. Executing a program may launch many processes.
    Processes should not have access to all of the system's resources. Processes are egotistical, and think they're the only one using the system, so if they could do as they pleased, they could make all sorts of changes that would be unbenificial to the rest of the system and the other processes.
    To gain access to the system's resources such as memory, the ability to communicate with I/O-devices, interprocess communication and more, the processes need to make system calls. System calls are directed to the OS (Operating System). The system can then perform these services fot the process, if it allowed this service.

    ----- 2.2 I/O REDIRECTION -----
    Communication between the system and the outside world happens through I/O(input/output)-devices, eg. the monitor and keyboard.
    This communication 'flows through' three standard data streams, the standard input stream (stdin), standard output stream (stdout) and standard error stream (stderr). These streams are directed to appropriate standard locations.
    The standards are:
    stdout carries output generated by a program to the terminal.
    stdin carries user input from the keyboard(thus, the user) to the system.
    stderr carries error-related output from the system to the monitor.
    A way to redirect streams is with pipes, a feature available in this shell. By using a pipe, the output from the first program, is redirected to be the input for the second program. Thus two streams are redirected in the context of the pipe: stdout for the first command and stdin for the second. After the commands have executed, the streams are back to normal.

    ----- 2.3 PROGRAM ENVIRONMENT -----
    The program environment is defined by environment variables, which are kept by the shell. Some variables are set by the system, others by you. An example of such a variable is PATH, which is the path to the directory, where shell looks for executables to run commands (This probably starts with something like "/usr/local/sbin..."). 
    Most programs need these environment variables to run. For example, exec() needs to know where to look for the file given to it, achieved via PATH. 
    
    
    ----- 2.4. BACKGROUND PROGRAM EXECUTION -----
    To run a process or a command from a terminal in the background without intervention from the user, you have to consider the following, when running such a background command one should use the syntax "(command) &". The '&' (ampersand) specifies to the terminal that this command should execute in the background, whereas the shell job ID will be printed to the terminal in order of execution. As a user can execute more than 1 background command at a time, it's useful to keep track of the progress of these, this can be done with the "jobs - 1" command, whereas the system will print the process ID and job state, of all user-started background processes. If you want to bring a background process into the foreground, you can use the "fg" command to bring forth the most recent background process. For a specific process, use the "fg %[process ID]". Sometimes a process doesn't behave as it should. This is where the "kill" command comes in handy. To kill a background process, simply type "kill [process ID]". If you want to move a foreground process to the background, you simply stop the execution of the process by typing "Ctrl+Z" followed by entering the command "bg". 

    Whenever the shell is terminated, the background processes receive a hangup signal, causing them to terminate as well. To prevent this from happening one can make the background processes run even after the shell is terminated. To disconnect a background process from the shell's job control, the shell built-in command "disown" is used to disconnect the current process. To target a specific process, use "disown %[ID]". (The ID can be either the process ID or the jobspec. The jobspec is the number assigned to the process when it is viewed with the "jobs" command as aforementioned.), another way to do the same is to use the command "nohup" this ignores all hangup signals, letting the processes continue running after the user has terminated the shell. 
